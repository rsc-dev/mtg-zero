#!/usr/bin/env python3
"""Extract rules outline from MTG Comprehensive Rules and generate index files.

This script reads the Comprehensive Rules text file and generates:
- docs/rules_index.md: A navigable table of contents
- docs/rules_coverage.yml: A coverage tracker (only if missing)

Usage:
    python tools/extract_rules_outline.py
    # or
    uv run python tools/extract_rules_outline.py
"""

from __future__ import annotations

import re
from pathlib import Path


def find_rules_file(docs_dir: Path) -> Path | None:
    """Find the Comprehensive Rules .txt file in docs/."""
    for f in docs_dir.glob("*.txt"):
        if "CompRules" in f.name or "comprehensive" in f.name.lower():
            return f
    # Fallback: any .txt file
    txt_files = list(docs_dir.glob("*.txt"))
    return txt_files[0] if txt_files else None


def extract_toc_from_rules(rules_path: Path) -> list[tuple[str, str]]:
    """Extract table of contents entries from the rules file.

    Returns a list of (number, title) tuples.
    """
    toc_entries: list[tuple[str, str]] = []
    in_toc = False
    toc_ended = False

    with open(rules_path, encoding="utf-8-sig") as f:
        for line in f:
            line = line.strip()

            # Start of TOC
            if line == "Contents":
                in_toc = True
                continue

            # End of TOC (when we hit the first actual rule section)
            if in_toc and line.startswith("1. Game Concepts") and toc_entries:
                # Check if this is the second occurrence (actual content, not TOC)
                if any(e[1] == "Game Concepts" for e in toc_entries):
                    toc_ended = True
                    break

            if not in_toc or toc_ended:
                continue

            # Skip empty lines
            if not line:
                continue

            # Match section headers like "1. Game Concepts"
            section_match = re.match(r"^(\d+)\.\s+(.+)$", line)
            if section_match:
                toc_entries.append((section_match.group(1), section_match.group(2)))
                continue

            # Match rule numbers like "100. General"
            rule_match = re.match(r"^(\d{3})\.\s+(.+)$", line)
            if rule_match:
                toc_entries.append((rule_match.group(1), rule_match.group(2)))
                continue

            # Match Glossary and Credits
            if line in ("Glossary", "Credits"):
                toc_entries.append(("", line))

    return toc_entries


def generate_rules_index(toc_entries: list[tuple[str, str]], rules_filename: str) -> str:
    """Generate the rules_index.md content."""
    lines = [
        "# Magic: The Gathering Comprehensive Rules Index",
        "",
        "This index is extracted from the official Comprehensive Rules.",
        "",
        f"Source file: `docs/{rules_filename}`",
        "",
        "---",
        "",
        "## Table of Contents",
        "",
    ]

    current_section = ""
    for num, title in toc_entries:
        # Section header (1-9)
        if num and len(num) == 1:
            current_section = title
            lines.append(f"### {num}. {title}")
            continue

        # Rule number (100-999)
        if num and len(num) == 3:
            lines.append(f"- {num}. {title}")
            continue

        # Glossary/Credits
        if not num and title:
            lines.append("")
            lines.append(f"### {title}")

    lines.append("")
    lines.append("---")
    lines.append("")
    lines.append("*Generated by tools/extract_rules_outline.py*")
    lines.append("")

    return "\n".join(lines)


def generate_initial_coverage() -> str:
    """Generate initial rules_coverage.yml content."""
    return """\
# MTG Rules Coverage Tracker
# Status: todo | partial | done
# Update this file as rules are implemented

# Core engine areas to track:

- id: "117"
  title: "Timing and Priority"
  status: todo
  code_refs: []
  notes: ""

- id: "405"
  title: "Stack"
  status: todo
  code_refs: []
  notes: ""

- id: "500-514"
  title: "Turn Structure"
  status: todo
  code_refs: []
  notes: ""

- id: "601"
  title: "Casting Spells"
  status: todo
  code_refs: []
  notes: ""

- id: "608"
  title: "Resolving Spells and Abilities"
  status: todo
  code_refs: []
  notes: ""

- id: "400-408"
  title: "Zones"
  status: todo
  code_refs: []
  notes: ""

- id: "109"
  title: "Objects"
  status: todo
  code_refs: []
  notes: ""

- id: "704"
  title: "State-Based Actions"
  status: todo
  code_refs: []
  notes: ""

- id: "603"
  title: "Handling Triggered Abilities"
  status: todo
  code_refs: []
  notes: ""

- id: "611"
  title: "Continuous Effects"
  status: todo
  code_refs: []
  notes: ""

- id: "613"
  title: "Interaction of Continuous Effects (Layers)"
  status: todo
  code_refs: []
  notes: ""
"""


def main() -> None:
    """Main entry point."""
    # Find project root (parent of tools/)
    script_dir = Path(__file__).parent
    project_root = script_dir.parent
    docs_dir = project_root / "docs"

    if not docs_dir.exists():
        print(f"Error: docs/ directory not found at {docs_dir}")
        return

    # Find rules file
    rules_file = find_rules_file(docs_dir)
    if not rules_file:
        print("Error: No Comprehensive Rules .txt file found in docs/")
        return

    print(f"Found rules file: {rules_file.name}")

    # Extract TOC
    toc_entries = extract_toc_from_rules(rules_file)
    print(f"Extracted {len(toc_entries)} TOC entries")

    # Generate rules_index.md
    index_content = generate_rules_index(toc_entries, rules_file.name)
    index_path = docs_dir / "rules_index.md"
    index_path.write_text(index_content, encoding="utf-8")
    print(f"Wrote {index_path}")

    # Generate rules_coverage.yml (only if missing)
    coverage_path = docs_dir / "rules_coverage.yml"
    if not coverage_path.exists():
        coverage_content = generate_initial_coverage()
        coverage_path.write_text(coverage_content, encoding="utf-8")
        print(f"Created {coverage_path}")
    else:
        print(f"Skipped {coverage_path} (already exists)")


if __name__ == "__main__":
    main()
